约定: G表示求最大公约数, R 表示取余.

提示: 正则序代换, 只有"基本运算符" + - * / = 等才会需要调用remainder, 过程调用只是去代换.

步骤 0 (调用gcd) => 0: (G 206 40)
步骤 1 (调用gcd) => 1: (G 40
                          (R 206 40))
步骤 2 (调用gcd) => 2: (G (R 206 40)
                          (R 40
                             (R 206 40)))
步骤 3 (调用gcd) => 4: (G (R 40
                             (R 206 40))
                          (R (R 206 40)
                             (R 40
                                (R 206 40))))
步骤 4 (调用gcd) => 7: (G (R (R 206 40)
                             (R 40
                                (R 206 40)))
                          (R (R 40
                                (R 206 40))
                             (R (R 206 40)
                                (R 40
                                   (R 206 40)))))
步骤 5 (求值a) => 4: (R (R 206 40)
                        (R 40
                           (R 206 40)))

总共: 0 + 1 + 2 + 4 + 7 + 4 = 18

那么, 有没有一个公式去计算这个关系呢?

让a[k]为第k步的"贡献".
那么a[0] = 0, a[1] = 1.
如果k是最后一步，则a[k] = a[k - 1] + a[k - 2] + 1,
否则a[k] = a[k - 2].

所以最终答案就是a[n] + a[n - 1] + ... + a[0],
其中n是gcd的迭代次数.
